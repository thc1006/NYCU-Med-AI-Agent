# å°ç£é†«ç™‚ AI åŠ©ç†ä½¿ç”¨æ–¹æ³•æŒ‡å—

> **å…è²¬è²æ˜ï¼šæœ¬ç³»çµ±åƒ…ä¾›ä¸€èˆ¬å¥åº·è³‡è¨Šåƒè€ƒï¼Œä¸å–ä»£å°ˆæ¥­é†«ç™‚è¨ºæ–·èˆ‡æ²»ç™‚ã€‚ç·Šæ€¥ç‹€æ³è«‹ç«‹å³æ’¥æ‰“ 119 æˆ– 112ã€‚**

## ç›®éŒ„

1. [ç³»çµ±æ¦‚è¿°](#ç³»çµ±æ¦‚è¿°)
2. [ç”¨æˆ¶æŒ‡å—](#ç”¨æˆ¶æŒ‡å—)
3. [API ä½¿ç”¨ç¯„ä¾‹](#api-ä½¿ç”¨ç¯„ä¾‹)
4. [å¸¸è¦‹ä½¿ç”¨å ´æ™¯](#å¸¸è¦‹ä½¿ç”¨å ´æ™¯)
5. [æ•´åˆæŒ‡å—](#æ•´åˆæŒ‡å—)
6. [æœ€ä½³å¯¦è¸](#æœ€ä½³å¯¦è¸)
7. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)
8. [å®‰å…¨èˆ‡éš±ç§](#å®‰å…¨èˆ‡éš±ç§)

---

## ç³»çµ±æ¦‚è¿°

å°ç£é†«ç™‚ AI åŠ©ç†æ˜¯ä¸€å€‹å°ˆç‚ºå°ç£é†«ç™‚ç’°å¢ƒè¨­è¨ˆçš„æ™ºæ…§å‹é†«ç™‚åŠ©ç†ç³»çµ±ï¼Œæä¾›ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

### ğŸ©º æ ¸å¿ƒåŠŸèƒ½
- **ç—‡ç‹€è©•ä¼°èˆ‡åˆ†ç´š**ï¼šæ™ºæ…§åˆ†æç—‡ç‹€åš´é‡ç¨‹åº¦ï¼Œæä¾›å°±é†«å»ºè­°
- **å°±è¿‘é†«é™¢æœå°‹**ï¼šåŸºæ–¼ä½ç½®çš„é†«ç™‚é™¢æ‰€æœå°‹èˆ‡å°èˆª
- **ç·Šæ€¥ç‹€æ³è¾¨è­˜**ï¼šè‡ªå‹•è­˜åˆ¥å±éšªç—‡ç‹€ï¼Œæä¾›æ€¥æ•‘æŒ‡å¼•
- **å¥åº·è³‡è¨ŠæŸ¥è©¢**ï¼šæä¾›è¡›ç¦éƒ¨èªè­‰çš„å¥åº·æ•™è‚²è³‡è¨Š

### ğŸ›¡ï¸ å®‰å…¨ç‰¹æ€§
- **PDPA åˆè¦**ï¼šç¬¦åˆå€‹äººè³‡æ–™ä¿è­·æ³•è¦ç¯„
- **éš±ç§ä¿è­·**ï¼šæ•æ„Ÿè³‡è¨Šè‡ªå‹•é®ç½©èˆ‡æœ€å°åŒ–è™•ç†
- **å°ç£åœ¨åœ°åŒ–**ï¼šä½¿ç”¨ç¹é«”ä¸­æ–‡èˆ‡å°ç£ç·Šæ€¥è¯çµ¡æ–¹å¼

### ğŸ“Š ç›£æ§åŠŸèƒ½
- **å³æ™‚å¥åº·ç›£æ§**ï¼šAPI æœå‹™ç‹€æ…‹èˆ‡æ•ˆèƒ½ç›£æ§
- **çµæ§‹åŒ–æ—¥èªŒ**ï¼šå®Œæ•´çš„æ“ä½œå¯©è¨ˆè¿½è¹¤
- **æ•ˆèƒ½åˆ†æ**ï¼šå›æ‡‰æ™‚é–“èˆ‡ç³»çµ±è³‡æºä½¿ç”¨åˆ†æ

---

## ç”¨æˆ¶æŒ‡å—

### ğŸ‘©â€âš•ï¸ é†«ç™‚å¾æ¥­äººå“¡

é†«è­·äººå“¡å¯ä»¥åˆ©ç”¨ç³»çµ±é€²è¡Œï¼š

#### å¿«é€Ÿç—‡ç‹€åˆ†æµ
- è¼”åŠ©ç—…æ‚£åˆæ­¥åˆ†ç´š
- ç·Šæ€¥ç‹€æ³å¿«é€Ÿè­˜åˆ¥
- è½‰è¨ºå»ºè­°åƒè€ƒ

#### ä½¿ç”¨ç¯„ä¾‹
```bash
# æŸ¥çœ‹æœå‹™ç‹€æ…‹
curl http://localhost:8000/v1/monitoring/health

# å¿«é€Ÿç—‡ç‹€è©•ä¼°
curl -X POST http://localhost:8000/v1/triage \
  -H "Content-Type: application/json" \
  -d '{
    "symptom_text": "èƒ¸ç—›ä¸¦ä¼´éš¨å‘¼å¸å›°é›£",
    "age": 45,
    "gender": "M"
  }'
```

### ğŸ’» è»Ÿé«”é–‹ç™¼è€…

é–‹ç™¼è€…å¯ä»¥æ•´åˆç³»çµ± API è‡³ç¾æœ‰æ‡‰ç”¨ç¨‹å¼ï¼š

#### åŸºæœ¬æ•´åˆæ­¥é©Ÿ
1. **ç’°å¢ƒè¨­å®š**
2. **API é‡‘é‘°é…ç½®**
3. **ç«¯é»æ¸¬è©¦**
4. **éŒ¯èª¤è™•ç†å¯¦ä½œ**

#### é–‹ç™¼å·¥å…·
- **API æ–‡ä»¶**ï¼š`http://localhost:8000/docs`
- **ç›£æ§å„€è¡¨æ¿**ï¼š`http://localhost:8000/v1/monitoring/dashboard`
- **å¥åº·æª¢æŸ¥**ï¼š`http://localhost:8000/healthz`

### ğŸ”§ ç³»çµ±ç®¡ç†å“¡

ç®¡ç†å“¡è² è²¬ç³»çµ±éƒ¨ç½²ã€ç›£æ§èˆ‡ç¶­è­·ï¼š

#### éƒ¨ç½²æª¢æŸ¥æ¸…å–®
- [ ] ç’°å¢ƒè®Šæ•¸é…ç½®
- [ ] Google API é‡‘é‘°è¨­å®š
- [ ] è³‡æ–™åº«é€£ç·šæ¸¬è©¦
- [ ] é˜²ç«ç‰†è¦å‰‡é…ç½®
- [ ] SSL æ†‘è­‰å®‰è£
- [ ] æ—¥èªŒè¼ªè½‰è¨­å®š

#### ç›£æ§é‡é»
```bash
# ç³»çµ±å¥åº·æª¢æŸ¥
curl http://localhost:8000/v1/monitoring/health

# æ•ˆèƒ½åº¦é‡æŸ¥è©¢
curl http://localhost:8000/v1/monitoring/metrics

# æ—¥èªŒåˆ†æ
tail -f logs/app.log | grep ERROR
```

### ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ä¸€èˆ¬æ°‘çœ¾

é€éå‰ç«¯æ‡‰ç”¨ç¨‹å¼æˆ–è¡Œå‹• APP ä½¿ç”¨ï¼š

#### ä¸»è¦åŠŸèƒ½
1. **ç—‡ç‹€è‡ªæˆ‘è©•ä¼°**
2. **å°±è¿‘é†«é™¢æœå°‹**
3. **ç·Šæ€¥è¯çµ¡è³‡è¨Š**
4. **å¥åº·æ•™è‚²è³‡æº**

---

## API ä½¿ç”¨ç¯„ä¾‹

### ğŸ¥ é†«é™¢æœå°‹ API

#### åŸºæœ¬æœå°‹ï¼ˆä½¿ç”¨åº§æ¨™ï¼‰
```bash
curl -X GET "http://localhost:8000/v1/hospitals/nearby?latitude=25.0330&longitude=121.5654&radius=3000" \
  -H "Accept: application/json"
```

**å›æ‡‰ç¯„ä¾‹ï¼š**
```json
{
  "results": [
    {
      "name": "è‡ºå¤§é†«é™¢",
      "address": "å°åŒ—å¸‚ä¸­æ­£å€å¸¸å¾·è¡—1è™Ÿ",
      "tel": "+886-2-23123456",
      "rating": 4.5,
      "opening_hours": "24 å°æ™‚æ€¥è¨º",
      "is_contracted": true,
      "distance_m": 820,
      "place_id": "ChIJXx1234...",
      "location": {
        "lat": 25.0330,
        "lng": 121.5654
      }
    }
  ],
  "emergency_numbers": ["119", "112"],
  "locale": "zh-TW",
  "request_id": "req_12345678"
}
```

#### åœ°å€æœå°‹
```bash
curl -X GET "http://localhost:8000/v1/hospitals/nearby?address=å°åŒ—å¸‚ä¿¡ç¾©å€&radius=5000" \
  -H "Accept: application/json"
```

#### Python ç¯„ä¾‹
```python
import requests
import json

# é†«é™¢æœå°‹
def search_nearby_hospitals(latitude, longitude, radius=3000):
    url = "http://localhost:8000/v1/hospitals/nearby"
    params = {
        "latitude": latitude,
        "longitude": longitude,
        "radius": radius,
        "max_results": 10
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"æœå°‹é†«é™¢æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        return None

# ä½¿ç”¨ç¯„ä¾‹
hospitals = search_nearby_hospitals(25.0330, 121.5654)
if hospitals:
    for hospital in hospitals['results']:
        print(f"é†«é™¢ï¼š{hospital['name']}")
        print(f"åœ°å€ï¼š{hospital['address']}")
        print(f"è·é›¢ï¼š{hospital['distance_m']} å…¬å°º")
        print("---")
```

### ğŸ©º ç—‡ç‹€åˆ†ç´š API

#### åŸºæœ¬ç—‡ç‹€è©•ä¼°
```bash
curl -X POST http://localhost:8000/v1/triage \
  -H "Content-Type: application/json" \
  -d '{
    "symptom_text": "é ­ç—›å·²æŒçºŒä¸‰å¤©ï¼Œä¼´éš¨ç™¼ç‡’",
    "age": 35,
    "gender": "F",
    "duration_hours": 72,
    "has_chronic_disease": false
  }'
```

**å›æ‡‰ç¯„ä¾‹ï¼š**
```json
{
  "level": "outpatient",
  "advice": "å»ºè­°å®‰æ’é–€è¨ºå°±é†«æª¢æŸ¥ï¼ŒæŒçºŒç™¼ç‡’è¶…éä¸‰å¤©éœ€è¦å°ˆæ¥­è©•ä¼°ã€‚",
  "next_steps": [
    "æ¸¬é‡ä¸¦è¨˜éŒ„é«”æº«è®ŠåŒ–",
    "å……åˆ†ä¼‘æ¯èˆ‡è£œå……æ°´åˆ†",
    "é¿å…æœç”¨éé‡é€€ç‡’è—¥",
    "å¦‚ç—‡ç‹€æƒ¡åŒ–è«‹ç«‹å³å°±é†«"
  ],
  "urgency_score": 6,
  "reasoning": "æŒçºŒç™¼ç‡’åˆä½µé ­ç—›éœ€è¦æ’é™¤æ„ŸæŸ“æˆ–å…¶ä»–ç–¾ç—…",
  "disclaimer": "æœ¬è©•ä¼°åƒ…ä¾›åƒè€ƒï¼Œä¸å–ä»£é†«å¸«è¨ºæ–·ã€‚å¦‚æœ‰ç–‘æ…®è«‹è«®è©¢é†«ç™‚å°ˆæ¥­äººå“¡ã€‚",
  "emergency_numbers": {
    "119": "æ¶ˆé˜²æ•‘è­·è»Š",
    "112": "è¡Œå‹•é›»è©±ç·Šæ€¥æ±‚æ•‘",
    "110": "è­¦å¯Ÿå±€"
  },
  "request_id": "req_87654321"
}
```

#### ç·Šæ€¥ç—‡ç‹€è©•ä¼°
```bash
curl -X POST http://localhost:8000/v1/triage \
  -H "Content-Type: application/json" \
  -d '{
    "symptom_text": "èƒ¸ç—›ã€å‘¼å¸å›°é›£ã€å†’å†·æ±—",
    "age": 55,
    "gender": "M"
  }'
```

**ç·Šæ€¥ç‹€æ³å›æ‡‰ï¼š**
```json
{
  "level": "emergency",
  "advice": "âš ï¸ ç«‹å³æ’¥æ‰“ 119 æˆ–å‰å¾€æœ€è¿‘æ€¥è¨ºå®¤ï¼é€™äº›ç—‡ç‹€å¯èƒ½è¡¨ç¤ºå¿ƒè‡Ÿç–¾ç—…æˆ–å…¶ä»–åš´é‡ç‹€æ³ã€‚",
  "next_steps": [
    "ç«‹å³æ’¥æ‰“ 119 æ±‚æ•‘",
    "ä¿æŒé®éœï¼Œå‹¿åŠ‡çƒˆæ´»å‹•",
    "æº–å‚™ç—…æ­·èˆ‡è—¥ç‰©æ¸…å–®",
    "é€šçŸ¥å®¶å±¬æˆ–ç·Šæ€¥è¯çµ¡äºº"
  ],
  "urgency_score": 10,
  "reasoning": "èƒ¸ç—›åˆä½µå‘¼å¸å›°é›£å’Œå†’æ±—æ˜¯å¿ƒè‡Ÿç—…ç™¼ä½œçš„å…¸å‹ç—‡ç‹€",
  "disclaimer": "âš ï¸ ç·Šæ€¥ç‹€æ³ï¼è«‹ç«‹å³å°‹æ±‚å°ˆæ¥­é†«ç™‚å”åŠ©ã€‚",
  "emergency_numbers": {
    "119": "æ¶ˆé˜²æ•‘è­·è»Š - ç«‹å³æ’¥æ‰“",
    "112": "è¡Œå‹•é›»è©±ç·Šæ€¥æ±‚æ•‘"
  },
  "nearest_hospitals": [
    {
      "name": "å°åŒ—æ¦®ç¸½æ€¥è¨º",
      "distance_m": 1200,
      "tel": "+886-2-28712121"
    }
  ]
}
```

#### Python ç¯„ä¾‹
```python
import requests

def assess_symptoms(symptom_text, age=None, gender=None):
    """ç—‡ç‹€è©•ä¼°å‡½æ•¸"""
    url = "http://localhost:8000/v1/triage"
    payload = {
        "symptom_text": symptom_text,
        "age": age,
        "gender": gender
    }

    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
        result = response.json()

        # è™•ç†å›æ‡‰
        print(f"åˆ†ç´šç­‰ç´šï¼š{result['level']}")
        print(f"å»ºè­°ï¼š{result['advice']}")

        if result['level'] == 'emergency':
            print("âš ï¸ ç·Šæ€¥ç‹€æ³ï¼è«‹ç«‹å³å°±é†«ï¼")

        return result

    except requests.exceptions.RequestException as e:
        print(f"è©•ä¼°ç—‡ç‹€æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        return None

# ä½¿ç”¨ç¯„ä¾‹
result = assess_symptoms("é ­ç—›ç™¼ç‡’", age=30, gender="F")
```

### ğŸ“Š ç›£æ§ API

#### ç³»çµ±å¥åº·æª¢æŸ¥
```bash
curl http://localhost:8000/v1/monitoring/health
```

#### æ•ˆèƒ½åº¦é‡
```bash
curl http://localhost:8000/v1/monitoring/metrics
```

#### å„€è¡¨æ¿è³‡æ–™
```bash
curl http://localhost:8000/v1/monitoring/dashboard
```

### ğŸŒ å…ƒè³‡æ–™ API

#### ç·Šæ€¥è¯çµ¡è³‡è¨Š
```bash
curl http://localhost:8000/v1/meta/emergency
```

**å›æ‡‰ç¯„ä¾‹ï¼š**
```json
{
  "numbers": [
    {
      "code": "119",
      "name": "æ¶ˆé˜²æ•‘è­·è»Š",
      "description": "ç«ç½ã€æ•‘è­·ã€æ•‘åŠ©æœå‹™"
    },
    {
      "code": "112",
      "name": "åœ‹éš›ç·Šæ€¥æ±‚æ•‘",
      "description": "è¡Œå‹•é›»è©±ç·Šæ€¥æ±‚æ•‘ï¼Œç„¡å¡äº¦å¯æ’¥æ‰“"
    },
    {
      "code": "110",
      "name": "è­¦å¯Ÿå±€",
      "description": "åˆ‘äº‹æ¡ˆä»¶ã€äº¤é€šäº‹æ•…å ±æ¡ˆ"
    }
  ],
  "updated_at": "2024-09-19T12:00:00Z"
}
```

---

## å¸¸è¦‹ä½¿ç”¨å ´æ™¯

### ğŸš¨ å ´æ™¯ä¸€ï¼šæ€¥è¨ºåˆ†æµ

**æƒ…å¢ƒ**ï¼šé†«é™¢æ€¥è¨ºç§‘éœ€è¦å¿«é€Ÿè©•ä¼°ç—…æ‚£æ€¥è¿«æ€§

```python
# æ€¥è¨ºåˆ†æµç³»çµ±æ•´åˆ
class EmergencyTriage:
    def __init__(self, api_base_url):
        self.api_url = api_base_url

    async def quick_assessment(self, patient_data):
        """å¿«é€Ÿè©•ä¼°ç—…æ‚£ç‹€æ³"""
        symptoms = patient_data.get('chief_complaint', '')
        age = patient_data.get('age')

        # å‘¼å«ç—‡ç‹€è©•ä¼° API
        response = await self.assess_symptoms(symptoms, age)

        if response['level'] == 'emergency':
            # ç«‹å³åˆ†é…è‡³æ€¥æ•‘å€
            await self.assign_to_emergency_bay(patient_data)
        elif response['level'] == 'urgent':
            # å„ªå…ˆè™•ç†éšŠåˆ—
            await self.add_to_priority_queue(patient_data)
        else:
            # ä¸€èˆ¬å€™è¨º
            await self.add_to_regular_queue(patient_data)

        return response
```

### ğŸ¥ å ´æ™¯äºŒï¼šé ç«¯é†«ç™‚è«®è©¢

**æƒ…å¢ƒ**ï¼šé ç«¯é†«ç™‚å¹³å°éœ€è¦åˆæ­¥ç—‡ç‹€ç¯©æª¢

```javascript
// é ç«¯é†«ç™‚å‰ç«¯æ•´åˆ
class TelemedicineConsult {
    constructor(apiEndpoint) {
        this.apiEndpoint = apiEndpoint;
    }

    async consultPatient(patientInput) {
        // ç—‡ç‹€è©•ä¼°
        const assessment = await this.assessSymptoms(patientInput);

        // æ ¹æ“šè©•ä¼°çµæœæ±ºå®šå¾ŒçºŒå‹•ä½œ
        if (assessment.level === 'emergency') {
            return this.handleEmergency(assessment);
        } else if (assessment.level === 'urgent') {
            return this.scheduleUrgentConsult(assessment);
        } else {
            return this.provideGeneralAdvice(assessment);
        }
    }

    handleEmergency(assessment) {
        return {
            message: 'å»ºè­°æ‚¨ç«‹å³å‰å¾€æ€¥è¨ºå®¤æˆ–æ’¥æ‰“119',
            nearbyHospitals: assessment.nearest_hospitals,
            immediateAction: true
        };
    }
}
```

### ğŸ“± å ´æ™¯ä¸‰ï¼šå¥åº·ç®¡ç† APP

**æƒ…å¢ƒ**ï¼šå€‹äººå¥åº·ç®¡ç†æ‡‰ç”¨ç¨‹å¼çš„ç—‡ç‹€è¨˜éŒ„åŠŸèƒ½

```python
# å¥åº·æ—¥è¨˜æ‡‰ç”¨ç¨‹å¼
class HealthDiary:
    def __init__(self):
        self.api_client = MedicalAIClient()

    def log_symptoms(self, user_id, symptom_description):
        """è¨˜éŒ„ç—‡ç‹€ä¸¦ç²å¾—å»ºè­°"""

        # å–å¾—ä½¿ç”¨è€…åŸºæœ¬è³‡æ–™
        user_profile = self.get_user_profile(user_id)

        # ç—‡ç‹€è©•ä¼°
        assessment = self.api_client.assess_symptoms(
            symptom_text=symptom_description,
            age=user_profile.age,
            gender=user_profile.gender,
            has_chronic_disease=user_profile.has_chronic_conditions
        )

        # å„²å­˜è¨˜éŒ„
        symptom_record = {
            'user_id': user_id,
            'timestamp': datetime.now(),
            'symptoms': symptom_description,
            'assessment': assessment,
            'action_taken': None
        }

        self.save_symptom_record(symptom_record)

        # ç™¼é€é€šçŸ¥
        if assessment['level'] in ['emergency', 'urgent']:
            self.send_alert_notification(user_id, assessment)

        return assessment
```

### ğŸ¢ å ´æ™¯å››ï¼šä¼æ¥­å¥åº·ç®¡ç†

**æƒ…å¢ƒ**ï¼šå…¬å¸å¥åº·ç®¡ç†ç³»çµ±çš„å“¡å·¥å¥åº·ç›£æ§

```python
# ä¼æ¥­å¥åº·ç®¡ç†ç³»çµ±
class CorporateHealthSystem:
    def __init__(self, company_id):
        self.company_id = company_id
        self.medical_ai = MedicalAIClient()

    def employee_health_check(self, employee_id, health_report):
        """å“¡å·¥å¥åº·ç‹€æ³æª¢æŸ¥"""

        # åˆ†æå¥åº·å ±å‘Š
        symptoms = self.extract_symptoms(health_report)

        if symptoms:
            assessment = self.medical_ai.assess_symptoms(
                symptom_text=symptoms,
                age=self.get_employee_age(employee_id)
            )

            # æ ¹æ“šè©•ä¼°çµæœæ¡å–è¡Œå‹•
            if assessment['level'] == 'emergency':
                self.trigger_emergency_protocol(employee_id)
            elif assessment['level'] == 'urgent':
                self.recommend_medical_leave(employee_id)

            # è¨˜éŒ„åˆ°å¥åº·ç®¡ç†ç³»çµ±
            self.log_health_assessment(employee_id, assessment)

            return assessment

        return None
```

---

## æ•´åˆæŒ‡å—

### ğŸ”§ æŠ€è¡“æ•´åˆ

#### REST API æ•´åˆ
```python
# API å®¢æˆ¶ç«¯å°è£
import requests
from typing import Optional, Dict, Any

class TaiwanMedicalAIClient:
    def __init__(self, base_url: str, api_key: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()

        # è¨­å®š headers
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'User-Agent': 'TaiwanMedicalAI-Client/1.0'
        })

        if api_key:
            self.session.headers['Authorization'] = f'Bearer {api_key}'

    def assess_symptoms(self, symptom_text: str, **kwargs) -> Dict[str, Any]:
        """ç—‡ç‹€è©•ä¼°"""
        url = f"{self.base_url}/v1/triage"
        payload = {
            'symptom_text': symptom_text,
            **kwargs
        }

        response = self.session.post(url, json=payload)
        response.raise_for_status()
        return response.json()

    def find_nearby_hospitals(self, latitude: float, longitude: float,
                            radius: int = 3000) -> Dict[str, Any]:
        """æœå°‹é™„è¿‘é†«é™¢"""
        url = f"{self.base_url}/v1/hospitals/nearby"
        params = {
            'latitude': latitude,
            'longitude': longitude,
            'radius': radius
        }

        response = self.session.get(url, params=params)
        response.raise_for_status()
        return response.json()

    def get_health_info(self, topic: str) -> Dict[str, Any]:
        """å–å¾—å¥åº·è³‡è¨Š"""
        url = f"{self.base_url}/v1/health-info/topics"
        params = {'topic': topic}

        response = self.session.get(url, params=params)
        response.raise_for_status()
        return response.json()
```

#### éåŒæ­¥æ•´åˆ
```python
import asyncio
import aiohttp
from typing import Optional, Dict, Any

class AsyncTaiwanMedicalAIClient:
    def __init__(self, base_url: str, api_key: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key

    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            headers={
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        )
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.session.close()

    async def assess_symptoms_async(self, symptom_text: str, **kwargs) -> Dict[str, Any]:
        """éåŒæ­¥ç—‡ç‹€è©•ä¼°"""
        url = f"{self.base_url}/v1/triage"
        payload = {
            'symptom_text': symptom_text,
            **kwargs
        }

        async with self.session.post(url, json=payload) as response:
            response.raise_for_status()
            return await response.json()

# ä½¿ç”¨ç¯„ä¾‹
async def main():
    async with AsyncTaiwanMedicalAIClient('http://localhost:8000') as client:
        result = await client.assess_symptoms_async('é ­ç—›ç™¼ç‡’')
        print(result)

# åŸ·è¡Œ
asyncio.run(main())
```

### ğŸŒ å‰ç«¯æ•´åˆ

#### JavaScript/TypeScript
```typescript
// TypeScript ä»‹é¢å®šç¾©
interface SymptomAssessmentRequest {
    symptom_text: string;
    age?: number;
    gender?: 'M' | 'F' | 'O';
    duration_hours?: number;
    has_chronic_disease?: boolean;
    medications?: string[];
}

interface TriageResponse {
    level: 'emergency' | 'urgent' | 'outpatient' | 'self-care';
    advice: string;
    next_steps: string[];
    urgency_score: number;
    reasoning: string;
    disclaimer: string;
    emergency_numbers: Record<string, string>;
    request_id: string;
}

class TaiwanMedicalAPI {
    private baseUrl: string;

    constructor(baseUrl: string = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }

    async assessSymptoms(request: SymptomAssessmentRequest): Promise<TriageResponse> {
        const response = await fetch(`${this.baseUrl}/v1/triage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(request)
        });

        if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }

    async findNearbyHospitals(lat: number, lng: number, radius: number = 3000) {
        const params = new URLSearchParams({
            latitude: lat.toString(),
            longitude: lng.toString(),
            radius: radius.toString()
        });

        const response = await fetch(`${this.baseUrl}/v1/hospitals/nearby?${params}`);

        if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    }
}
```

#### React Hook ç¯„ä¾‹
```jsx
import { useState, useCallback } from 'react';
import { TaiwanMedicalAPI } from './api/TaiwanMedicalAPI';

// è‡ªå®šç¾© Hook
export const useMedicalAssessment = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [result, setResult] = useState(null);

    const api = new TaiwanMedicalAPI();

    const assessSymptoms = useCallback(async (symptomData) => {
        setLoading(true);
        setError(null);

        try {
            const response = await api.assessSymptoms(symptomData);
            setResult(response);
            return response;
        } catch (err) {
            setError(err.message);
            throw err;
        } finally {
            setLoading(false);
        }
    }, []);

    return {
        assessSymptoms,
        loading,
        error,
        result
    };
};

// React å…ƒä»¶ç¯„ä¾‹
export const SymptomChecker = () => {
    const { assessSymptoms, loading, error, result } = useMedicalAssessment();
    const [symptomText, setSymptomText] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();

        if (!symptomText.trim()) {
            alert('è«‹è¼¸å…¥ç—‡ç‹€æè¿°');
            return;
        }

        try {
            await assessSymptoms({ symptom_text: symptomText });
        } catch (err) {
            console.error('ç—‡ç‹€è©•ä¼°å¤±æ•—:', err);
        }
    };

    return (
        <div className="symptom-checker">
            <form onSubmit={handleSubmit}>
                <textarea
                    value={symptomText}
                    onChange={(e) => setSymptomText(e.target.value)}
                    placeholder="è«‹æè¿°æ‚¨çš„ç—‡ç‹€..."
                    rows={4}
                    disabled={loading}
                />
                <button type="submit" disabled={loading || !symptomText.trim()}>
                    {loading ? 'è©•ä¼°ä¸­...' : 'é–‹å§‹è©•ä¼°'}
                </button>
            </form>

            {error && (
                <div className="error">
                    éŒ¯èª¤ï¼š{error}
                </div>
            )}

            {result && (
                <div className={`result level-${result.level}`}>
                    <h3>è©•ä¼°çµæœ</h3>
                    <p><strong>ç´šåˆ¥ï¼š</strong>{result.level}</p>
                    <p><strong>å»ºè­°ï¼š</strong>{result.advice}</p>

                    {result.level === 'emergency' && (
                        <div className="emergency-alert">
                            âš ï¸ ç·Šæ€¥ç‹€æ³ï¼è«‹ç«‹å³æ’¥æ‰“ 119
                        </div>
                    )}

                    <details>
                        <summary>è©³ç´°å»ºè­°</summary>
                        <ul>
                            {result.next_steps.map((step, index) => (
                                <li key={index}>{step}</li>
                            ))}
                        </ul>
                    </details>
                </div>
            )}
        </div>
    );
};
```

### ğŸ¥ é†«ç™‚ç³»çµ±æ•´åˆ

#### HIS (Hospital Information System) æ•´åˆ
```python
# é†«é™¢è³‡è¨Šç³»çµ±æ•´åˆç¯„ä¾‹
class HISIntegration:
    def __init__(self, his_database, medical_ai_client):
        self.his_db = his_database
        self.ai_client = medical_ai_client

    def enhanced_admission_triage(self, patient_id, chief_complaint):
        """å¢å¼·å‹å…¥é™¢åˆ†æµ"""

        # å¾ HIS å–å¾—ç—…æ‚£è³‡æ–™
        patient = self.his_db.get_patient(patient_id)

        # AI ç—‡ç‹€è©•ä¼°
        assessment = self.ai_client.assess_symptoms(
            symptom_text=chief_complaint,
            age=patient.age,
            gender=patient.gender,
            has_chronic_disease=len(patient.chronic_conditions) > 0,
            medications=[med.name for med in patient.current_medications]
        )

        # çµåˆ HIS è³‡æ–™èˆ‡ AI è©•ä¼°
        enhanced_triage = {
            'patient_id': patient_id,
            'ai_assessment': assessment,
            'medical_history': patient.medical_history,
            'vital_signs': patient.latest_vitals,
            'recommended_department': self.determine_department(assessment),
            'priority_score': self.calculate_priority(assessment, patient)
        }

        # æ›´æ–° HIS åˆ†æµè³‡æ–™
        self.his_db.update_triage_data(patient_id, enhanced_triage)

        return enhanced_triage

    def determine_department(self, assessment):
        """æ ¹æ“šè©•ä¼°çµæœæ±ºå®šç§‘å®¤"""
        if assessment['level'] == 'emergency':
            return 'emergency_department'
        elif 'chest_pain' in assessment.get('detected_symptoms', []):
            return 'cardiology'
        elif 'headache' in assessment.get('detected_symptoms', []):
            return 'neurology'
        else:
            return 'general_medicine'
```

---

## æœ€ä½³å¯¦è¸

### ğŸ¯ ç—‡ç‹€è¼¸å…¥æœ€ä½³å¯¦è¸

#### è©³ç´°æè¿°ç—‡ç‹€
```python
# âŒ ä¸å¥½çš„ç¯„ä¾‹
symptom_text = "ä¸èˆ’æœ"

# âœ… å¥½çš„ç¯„ä¾‹
symptom_text = "å³ä¸‹è…¹ç–¼ç—›æŒçºŒ6å°æ™‚ï¼Œä¼´éš¨å™å¿ƒå’Œè¼•å¾®ç™¼ç‡’37.5Â°C"
```

#### æä¾›ç›¸é—œèƒŒæ™¯è³‡è¨Š
```python
# å®Œæ•´çš„ç—‡ç‹€è©•ä¼°è«‹æ±‚
assessment_request = {
    "symptom_text": "èƒ¸ç—›ä¸¦å»¶ä¼¸è‡³å·¦è‡‚ï¼ŒæŒçºŒç´„30åˆ†é˜",
    "age": 55,
    "gender": "M",
    "duration_hours": 0.5,
    "has_chronic_disease": True,  # æœ‰é«˜è¡€å£“ç—…å²
    "medications": ["é™è¡€å£“è—¥", "é˜¿æ–¯åŒ¹éˆ"],
    "activity_when_started": "çˆ¬æ¨“æ¢¯æ™‚é–‹å§‹",
    "pain_scale": 8  # 1-10åˆ†ç–¼ç—›é‡è¡¨
}
```

### ğŸš¨ ç·Šæ€¥ç‹€æ³è™•ç†æµç¨‹

#### è‡ªå‹•ç·Šæ€¥ç‹€æ³æª¢æ¸¬
```python
def handle_emergency_assessment(assessment_result):
    """è™•ç†ç·Šæ€¥è©•ä¼°çµæœ"""

    if assessment_result['level'] == 'emergency':
        # 1. ç«‹å³è¨˜éŒ„è­¦å ±
        log_emergency_alert(assessment_result)

        # 2. è§¸ç™¼é€šçŸ¥æ©Ÿåˆ¶
        notify_emergency_contacts(assessment_result)

        # 3. æä¾›æœ€è¿‘é†«é™¢è³‡è¨Š
        if 'nearest_hospitals' in assessment_result:
            display_emergency_hospitals(assessment_result['nearest_hospitals'])

        # 4. é¡¯ç¤ºç·Šæ€¥æŒ‡å¼•
        show_emergency_instructions(assessment_result['emergency_numbers'])

        return {
            'immediate_action': True,
            'message': 'âš ï¸ ç·Šæ€¥ç‹€æ³ï¼è«‹ç«‹å³æ’¥æ‰“119æˆ–å‰å¾€æ€¥è¨º',
            'hospitals': assessment_result.get('nearest_hospitals', []),
            'emergency_numbers': assessment_result['emergency_numbers']
        }

    return None
```

### ğŸ¥ é†«é™¢æœå°‹å„ªåŒ–æ–¹æ³•

#### æ™ºæ…§åŠå¾‘èª¿æ•´
```python
def smart_hospital_search(latitude, longitude, initial_radius=3000):
    """æ™ºæ…§é†«é™¢æœå°‹ï¼Œè‡ªå‹•èª¿æ•´æœå°‹åŠå¾‘"""

    radius = initial_radius
    max_radius = 20000  # æœ€å¤§20å…¬é‡Œ
    min_results = 3     # æœ€å°‘é†«é™¢æ•¸é‡

    while radius <= max_radius:
        hospitals = search_nearby_hospitals(
            latitude=latitude,
            longitude=longitude,
            radius=radius
        )

        if len(hospitals['results']) >= min_results:
            return hospitals

        # æ“´å¤§æœå°‹ç¯„åœ
        radius += 2000

    # å¦‚æœä»æ‰¾ä¸åˆ°è¶³å¤ é†«é™¢ï¼Œè¿”å›æœ€å¤§ç¯„åœçš„çµæœ
    return search_nearby_hospitals(latitude, longitude, max_radius)
```

#### é†«é™¢ç¯©é¸èˆ‡æ’åº
```python
def filter_and_sort_hospitals(hospitals, preferences=None):
    """ç¯©é¸å’Œæ’åºé†«é™¢çµæœ"""

    if not preferences:
        preferences = {
            'emergency_only': False,
            'contracted_only': True,  # åªé¡¯ç¤ºå¥ä¿ç‰¹ç´„
            'min_rating': 3.0,
            'max_distance_m': 10000
        }

    filtered = []

    for hospital in hospitals['results']:
        # ç¯©é¸æ¢ä»¶
        if preferences['emergency_only'] and not hospital.get('has_emergency', False):
            continue

        if preferences['contracted_only'] and not hospital.get('is_contracted', False):
            continue

        if hospital.get('rating', 0) < preferences['min_rating']:
            continue

        if hospital.get('distance_m', float('inf')) > preferences['max_distance_m']:
            continue

        filtered.append(hospital)

    # æ’åºï¼šæ€¥è¨ºé†«é™¢å„ªå…ˆï¼Œç„¶å¾ŒæŒ‰è·é›¢
    def sort_key(hospital):
        has_emergency = hospital.get('has_emergency', False)
        distance = hospital.get('distance_m', float('inf'))
        rating = hospital.get('rating', 0)

        # æ€¥è¨ºé†«é™¢å„ªå…ˆæ¬Šé‡
        emergency_weight = 0 if has_emergency else 10000

        return emergency_weight + distance - (rating * 100)

    filtered.sort(key=sort_key)

    return {
        'results': filtered,
        'total_found': len(filtered),
        'search_criteria': preferences
    }
```

### ğŸ“Š ç³»çµ±ç›£æ§ä½¿ç”¨æ–¹æ³•

#### è‡ªå‹•å¥åº·æª¢æŸ¥
```python
import asyncio
import aiohttp
from datetime import datetime, timedelta

class SystemHealthMonitor:
    def __init__(self, api_base_url):
        self.api_url = api_base_url
        self.check_interval = 60  # æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
        self.alert_thresholds = {
            'response_time_ms': 5000,
            'error_rate_percent': 5.0,
            'memory_usage_percent': 85.0
        }

    async def continuous_monitoring(self):
        """æŒçºŒç›£æ§ç³»çµ±ç‹€æ…‹"""
        while True:
            try:
                health_status = await self.check_system_health()

                # æª¢æŸ¥è­¦å ±æ¢ä»¶
                if self.should_alert(health_status):
                    await self.send_alert(health_status)

                # è¨˜éŒ„ç‹€æ…‹
                self.log_health_status(health_status)

            except Exception as e:
                await self.handle_monitoring_error(e)

            await asyncio.sleep(self.check_interval)

    async def check_system_health(self):
        """æª¢æŸ¥ç³»çµ±å¥åº·ç‹€æ…‹"""
        async with aiohttp.ClientSession() as session:
            start_time = datetime.now()

            # å¥åº·æª¢æŸ¥
            async with session.get(f'{self.api_url}/v1/monitoring/health') as response:
                response_time = (datetime.now() - start_time).total_seconds() * 1000
                health_data = await response.json()

                # å–å¾—è©³ç´°åº¦é‡
                async with session.get(f'{self.api_url}/v1/monitoring/metrics') as metrics_response:
                    metrics_data = await metrics_response.json()

                return {
                    'timestamp': datetime.now().isoformat(),
                    'response_time_ms': response_time,
                    'status_code': response.status,
                    'health_data': health_data,
                    'metrics': metrics_data
                }

    def should_alert(self, health_status):
        """åˆ¤æ–·æ˜¯å¦éœ€è¦ç™¼é€è­¦å ±"""
        if health_status['status_code'] != 200:
            return True

        if health_status['response_time_ms'] > self.alert_thresholds['response_time_ms']:
            return True

        metrics = health_status.get('metrics', {})
        error_rate = metrics.get('error_rate_percent', 0)
        if error_rate > self.alert_thresholds['error_rate_percent']:
            return True

        return False
```

### âš¡ æ•ˆèƒ½å„ªåŒ–å»ºè­°

#### è«‹æ±‚å¿«å–ç­–ç•¥
```python
import redis
import json
from functools import wraps
from datetime import timedelta

class APICache:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.default_ttl = 300  # 5åˆ†é˜

    def cache_result(self, key_prefix, ttl=None):
        """API çµæœå¿«å–è£é£¾å™¨"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                # ç”¢ç”Ÿå¿«å–éµ
                cache_key = f"{key_prefix}:{hash(str(args) + str(kwargs))}"

                # å˜—è©¦å¾å¿«å–å–å¾—
                cached_result = self.redis.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)

                # åŸ·è¡ŒåŸå‡½æ•¸
                result = await func(*args, **kwargs)

                # å„²å­˜åˆ°å¿«å–
                ttl_seconds = ttl or self.default_ttl
                self.redis.setex(
                    cache_key,
                    ttl_seconds,
                    json.dumps(result, ensure_ascii=False)
                )

                return result

            return wrapper
        return decorator

# ä½¿ç”¨ç¯„ä¾‹
cache = APICache(redis.Redis(host='localhost', port=6379, db=0))

@cache.cache_result('hospital_search', ttl=600)  # å¿«å–10åˆ†é˜
async def cached_hospital_search(lat, lng, radius):
    return await search_nearby_hospitals(lat, lng, radius)
```

#### æ‰¹æ¬¡è«‹æ±‚è™•ç†
```python
class BatchRequestProcessor:
    def __init__(self, batch_size=10, timeout_seconds=5):
        self.batch_size = batch_size
        self.timeout = timeout_seconds
        self.pending_requests = []

    async def add_request(self, request_data):
        """æ–°å¢è«‹æ±‚åˆ°æ‰¹æ¬¡è™•ç†ä½‡åˆ—"""
        self.pending_requests.append(request_data)

        # å¦‚æœé”åˆ°æ‰¹æ¬¡å¤§å°ï¼Œç«‹å³è™•ç†
        if len(self.pending_requests) >= self.batch_size:
            return await self.process_batch()

        # å¦å‰‡ç­‰å¾…è¶…æ™‚
        await asyncio.sleep(self.timeout)
        if self.pending_requests:
            return await self.process_batch()

    async def process_batch(self):
        """è™•ç†ä¸€æ‰¹è«‹æ±‚"""
        if not self.pending_requests:
            return []

        current_batch = self.pending_requests.copy()
        self.pending_requests.clear()

        # ä¸¦è¡Œè™•ç†å¤šå€‹è«‹æ±‚
        tasks = [
            self.process_single_request(req)
            for req in current_batch
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
```

---

## æ•…éšœæ’é™¤

### ğŸ” å¸¸è¦‹å•é¡Œè¨ºæ–·

#### API é€£ç·šå•é¡Œ
```bash
# æª¢æŸ¥æœå‹™ç‹€æ…‹
curl -I http://localhost:8000/healthz

# æª¢æŸ¥ç¶²è·¯é€£é€šæ€§
ping localhost

# æª¢æŸ¥åŸ å£å ç”¨
netstat -tulpn | grep :8000

# æª¢æŸ¥é˜²ç«ç‰†è¨­å®š
sudo ufw status
```

#### æ•ˆèƒ½å•é¡Œè¨ºæ–·
```python
import time
import psutil
import requests
from datetime import datetime

def diagnose_performance_issues(api_url):
    """è¨ºæ–· API æ•ˆèƒ½å•é¡Œ"""

    # 1. æ¸¬è©¦å›æ‡‰æ™‚é–“
    start_time = time.time()
    try:
        response = requests.get(f"{api_url}/healthz", timeout=10)
        response_time = (time.time() - start_time) * 1000

        print(f"API å›æ‡‰æ™‚é–“: {response_time:.2f} ms")

        if response_time > 5000:
            print("âš ï¸ å›æ‡‰æ™‚é–“éæ…¢")
    except requests.Timeout:
        print("âŒ API å›æ‡‰è¶…æ™‚")
    except requests.ConnectionError:
        print("âŒ ç„¡æ³•é€£ç·šåˆ° API")

    # 2. æª¢æŸ¥ç³»çµ±è³‡æº
    cpu_usage = psutil.cpu_percent(interval=1)
    memory = psutil.virtual_memory()
    disk = psutil.disk_usage('/')

    print(f"CPU ä½¿ç”¨ç‡: {cpu_usage}%")
    print(f"è¨˜æ†¶é«”ä½¿ç”¨ç‡: {memory.percent}%")
    print(f"ç£ç¢Ÿä½¿ç”¨ç‡: {disk.percent}%")

    # 3. è­¦å‘Šæ¢ä»¶
    if cpu_usage > 80:
        print("âš ï¸ CPU ä½¿ç”¨ç‡éé«˜")
    if memory.percent > 85:
        print("âš ï¸ è¨˜æ†¶é«”ä½¿ç”¨ç‡éé«˜")
    if disk.percent > 90:
        print("âš ï¸ ç£ç¢Ÿç©ºé–“ä¸è¶³")

    return {
        'response_time_ms': response_time,
        'cpu_usage_percent': cpu_usage,
        'memory_usage_percent': memory.percent,
        'disk_usage_percent': disk.percent
    }
```

### ğŸš¨ éŒ¯èª¤è™•ç†

#### æ¨™æº–éŒ¯èª¤å›æ‡‰æ ¼å¼
```json
{
  "error": {
    "code": "SYMPTOM_ASSESSMENT_FAILED",
    "message": "ç—‡ç‹€è©•ä¼°æœå‹™æš«æ™‚ç„¡æ³•ä½¿ç”¨",
    "details": "å¤–éƒ¨ API å›æ‡‰è¶…æ™‚",
    "timestamp": "2024-09-19T12:00:00Z",
    "request_id": "req_12345678",
    "suggested_action": "è«‹ç¨å¾Œå†è©¦ï¼Œæˆ–ç›´æ¥æ’¥æ‰“119å°‹æ±‚å”åŠ©"
  }
}
```

#### éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸
```python
class MedicalAIErrorHandler:
    def __init__(self):
        self.error_codes = {
            'API_UNAVAILABLE': 'æœå‹™æš«æ™‚ç„¡æ³•ä½¿ç”¨',
            'INVALID_SYMPTOMS': 'ç—‡ç‹€æè¿°æ ¼å¼ç„¡æ•ˆ',
            'GEOCODING_FAILED': 'åœ°å€è§£æå¤±æ•—',
            'NO_HOSPITALS_FOUND': 'é™„è¿‘æœªæ‰¾åˆ°é†«é™¢',
            'RATE_LIMIT_EXCEEDED': 'è«‹æ±‚é »ç‡éé«˜'
        }

    def handle_api_error(self, error, request_context=None):
        """è™•ç† API éŒ¯èª¤"""

        if isinstance(error, requests.ConnectionError):
            return self.create_error_response(
                'API_UNAVAILABLE',
                'ç„¡æ³•é€£ç·šåˆ°é†«ç™‚è©•ä¼°æœå‹™',
                suggested_action='è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦'
            )

        elif isinstance(error, requests.Timeout):
            return self.create_error_response(
                'API_TIMEOUT',
                'æœå‹™å›æ‡‰è¶…æ™‚',
                suggested_action='è«‹ç¨å¾Œå†è©¦ï¼Œç·Šæ€¥æƒ…æ³è«‹æ’¥æ‰“119'
            )

        elif hasattr(error, 'response') and error.response:
            status_code = error.response.status_code

            if status_code == 400:
                return self.create_error_response(
                    'INVALID_REQUEST',
                    'è«‹æ±‚æ ¼å¼éŒ¯èª¤',
                    suggested_action='è«‹æª¢æŸ¥è¼¸å…¥çš„ç—‡ç‹€æè¿°'
                )

            elif status_code == 429:
                return self.create_error_response(
                    'RATE_LIMIT_EXCEEDED',
                    'è«‹æ±‚éæ–¼é »ç¹',
                    suggested_action='è«‹ç¨å¾Œå†è©¦'
                )

            elif status_code >= 500:
                return self.create_error_response(
                    'SERVER_ERROR',
                    'æœå‹™å™¨å…§éƒ¨éŒ¯èª¤',
                    suggested_action='è«‹ç¨å¾Œå†è©¦æˆ–è¯çµ¡æŠ€è¡“æ”¯æ´'
                )

        # é è¨­éŒ¯èª¤è™•ç†
        return self.create_error_response(
            'UNKNOWN_ERROR',
            'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤',
            suggested_action='è«‹ç¨å¾Œå†è©¦ï¼Œç·Šæ€¥æƒ…æ³è«‹æ’¥æ‰“119'
        )

    def create_error_response(self, code, message, suggested_action=None):
        """å»ºç«‹æ¨™æº–éŒ¯èª¤å›æ‡‰"""
        return {
            'error': {
                'code': code,
                'message': message,
                'timestamp': datetime.now().isoformat(),
                'suggested_action': suggested_action or 'è«‹ç¨å¾Œå†è©¦'
            }
        }
```

### ğŸ“‹ æ•…éšœæ’é™¤æª¢æŸ¥æ¸…å–®

#### æœå‹™å•Ÿå‹•å•é¡Œ
- [ ] ç’°å¢ƒè®Šæ•¸æ˜¯å¦æ­£ç¢ºè¨­å®š
- [ ] Google API é‡‘é‘°æ˜¯å¦æœ‰æ•ˆ
- [ ] åŸ å£ 8000 æ˜¯å¦è¢«å ç”¨
- [ ] Python ä¾è³´å¥—ä»¶æ˜¯å¦å®Œæ•´å®‰è£
- [ ] è³‡æ–™åº«é€£ç·šæ˜¯å¦æ­£å¸¸

#### API å‘¼å«å•é¡Œ
- [ ] API ç«¯é» URL æ˜¯å¦æ­£ç¢º
- [ ] è«‹æ±‚æ ¼å¼æ˜¯å¦ç¬¦åˆè¦ç¯„
- [ ] å¿…è¦åƒæ•¸æ˜¯å¦å®Œæ•´æä¾›
- [ ] Content-Type æ¨™é ­æ˜¯å¦æ­£ç¢º
- [ ] ç¶²è·¯é˜²ç«ç‰†æ˜¯å¦å…è¨±é€£ç·š

#### æ•ˆèƒ½å•é¡Œ
- [ ] æœå‹™å™¨ CPU å’Œè¨˜æ†¶é«”ä½¿ç”¨ç‡
- [ ] ç¶²è·¯å»¶é²å’Œé »å¯¬
- [ ] å¤–éƒ¨ API (Google Places) é…é¡
- [ ] è³‡æ–™åº«æŸ¥è©¢æ•ˆèƒ½
- [ ] å¿«å–æ©Ÿåˆ¶æ˜¯å¦æ­£å¸¸é‹ä½œ

---

## å®‰å…¨èˆ‡éš±ç§

### ğŸ”’ PDPA åˆè¦è¦æ±‚

#### å€‹äººè³‡æ–™æœ€å°åŒ–
```python
class PrivacyManager:
    def __init__(self):
        self.sensitive_fields = [
            'phone', 'id_number', 'address', 'email',
            'full_name', 'birthday'
        ]

    def sanitize_input(self, data):
        """æ¸…ç†æ•æ„Ÿè³‡æ–™"""
        if isinstance(data, dict):
            for key, value in data.items():
                if key in self.sensitive_fields:
                    data[key] = self.mask_sensitive_data(value)
                elif isinstance(value, (dict, list)):
                    data[key] = self.sanitize_input(value)

        elif isinstance(data, list):
            data = [self.sanitize_input(item) for item in data]

        return data

    def mask_sensitive_data(self, value):
        """é®ç½©æ•æ„Ÿè³‡æ–™"""
        if not value:
            return value

        value_str = str(value)

        # é›»è©±è™Ÿç¢¼é®ç½©
        if re.match(r'^\d{4}-?\d{3}-?\d{3}$', value_str):
            return value_str[:4] + '***' + value_str[-3:]

        # èº«åˆ†è­‰è™Ÿé®ç½©
        if re.match(r'^[A-Z]\d{9}$', value_str):
            return value_str[:2] + '*****' + value_str[-2:]

        # ä¸€èˆ¬é®ç½©
        if len(value_str) > 3:
            return value_str[:2] + '*' * (len(value_str) - 3) + value_str[-1:]

        return '***'
```

#### å¯©è¨ˆæ—¥èªŒè¨˜éŒ„
```python
import json
import hashlib
from datetime import datetime

class AuditLogger:
    def __init__(self, log_file_path):
        self.log_file = log_file_path

    def log_medical_query(self, request_data, response_data, user_context=None):
        """è¨˜éŒ„é†«ç™‚æŸ¥è©¢å¯©è¨ˆæ—¥èªŒ"""

        # ä¸è¨˜éŒ„æ•æ„Ÿå…§å®¹ï¼Œåªè¨˜éŒ„å¿…è¦çš„å¯©è¨ˆè³‡è¨Š
        audit_record = {
            'timestamp': datetime.now().isoformat(),
            'request_id': request_data.get('request_id'),
            'query_type': self.determine_query_type(request_data),
            'response_level': response_data.get('level'),
            'user_age_group': self.anonymize_age(request_data.get('age')),
            'symptom_hash': self.hash_symptom(request_data.get('symptom_text')),
            'ip_hash': self.hash_ip(user_context.get('ip_address') if user_context else None),
            'processing_time_ms': response_data.get('processing_time_ms'),
            'emergency_triggered': response_data.get('level') == 'emergency'
        }

        self.write_audit_log(audit_record)

    def hash_symptom(self, symptom_text):
        """ç—‡ç‹€æ–‡å­—é›œæ¹ŠåŒ–"""
        if not symptom_text:
            return None

        # ä½¿ç”¨ SHA-256 é›œæ¹Šï¼Œç„¡æ³•é‚„åŸåŸå§‹æ–‡å­—
        return hashlib.sha256(symptom_text.encode('utf-8')).hexdigest()[:16]

    def anonymize_age(self, age):
        """å¹´é½¡åŒ¿ååŒ–"""
        if not age:
            return None

        # å°‡å¹´é½¡åˆ†çµ„ï¼Œé¿å…ç²¾ç¢ºå¹´é½¡è³‡è¨Š
        if age < 18:
            return 'minor'
        elif age < 30:
            return '18-29'
        elif age < 50:
            return '30-49'
        elif age < 65:
            return '50-64'
        else:
            return '65+'

    def write_audit_log(self, record):
        """å¯«å…¥å¯©è¨ˆæ—¥èªŒ"""
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(record, ensure_ascii=False) + '\n')
```

### ğŸ›¡ï¸ API å®‰å…¨æªæ–½

#### é€Ÿç‡é™åˆ¶
```python
from fastapi import HTTPException
import time
from collections import defaultdict

class RateLimiter:
    def __init__(self, max_requests=100, time_window=3600):
        self.max_requests = max_requests
        self.time_window = time_window  # ç§’
        self.requests = defaultdict(list)

    def check_rate_limit(self, client_id):
        """æª¢æŸ¥é€Ÿç‡é™åˆ¶"""
        now = time.time()
        client_requests = self.requests[client_id]

        # ç§»é™¤éæœŸçš„è«‹æ±‚è¨˜éŒ„
        client_requests[:] = [
            req_time for req_time in client_requests
            if now - req_time < self.time_window
        ]

        # æª¢æŸ¥æ˜¯å¦è¶…éé™åˆ¶
        if len(client_requests) >= self.max_requests:
            raise HTTPException(
                status_code=429,
                detail={
                    'error': 'Rate limit exceeded',
                    'message': f'æ¯å°æ™‚æœ€å¤š {self.max_requests} æ¬¡è«‹æ±‚',
                    'retry_after': self.time_window - (now - client_requests[0])
                }
            )

        # è¨˜éŒ„æ–°è«‹æ±‚
        client_requests.append(now)

        return True
```

#### è¼¸å…¥é©—è­‰èˆ‡æ¸…ç†
```python
import re
from typing import Any, Dict

class InputValidator:
    def __init__(self):
        self.max_symptom_length = 1000
        self.forbidden_patterns = [
            r'<script[^>]*>.*?</script>',  # XSS é˜²è­·
            r'javascript:',
            r'on\w+\s*=',  # äº‹ä»¶è™•ç†å™¨
        ]

    def validate_symptom_input(self, symptom_text: str) -> str:
        """é©—è­‰ä¸¦æ¸…ç†ç—‡ç‹€è¼¸å…¥"""
        if not symptom_text:
            raise ValueError('ç—‡ç‹€æè¿°ä¸èƒ½ç‚ºç©º')

        if len(symptom_text) > self.max_symptom_length:
            raise ValueError(f'ç—‡ç‹€æè¿°éé•·ï¼Œæœ€å¤š {self.max_symptom_length} å­—å…ƒ')

        # æª¢æŸ¥æƒ¡æ„æ¨¡å¼
        for pattern in self.forbidden_patterns:
            if re.search(pattern, symptom_text, re.IGNORECASE):
                raise ValueError('è¼¸å…¥åŒ…å«ä¸å…è¨±çš„å…§å®¹')

        # æ¸…ç† HTML æ¨™ç±¤
        clean_text = re.sub(r'<[^>]+>', '', symptom_text)

        # ç§»é™¤å¤šé¤˜ç©ºç™½
        clean_text = re.sub(r'\s+', ' ', clean_text).strip()

        return clean_text

    def validate_coordinates(self, latitude: float, longitude: float) -> bool:
        """é©—è­‰åº§æ¨™ç¯„åœï¼ˆå°ç£åœ°å€ï¼‰"""
        # å°ç£åº§æ¨™ç¯„åœ
        taiwan_bounds = {
            'lat_min': 21.0, 'lat_max': 26.0,
            'lng_min': 119.0, 'lng_max': 122.5
        }

        if not (taiwan_bounds['lat_min'] <= latitude <= taiwan_bounds['lat_max']):
            raise ValueError('ç·¯åº¦è¶…å‡ºå°ç£åœ°å€ç¯„åœ')

        if not (taiwan_bounds['lng_min'] <= longitude <= taiwan_bounds['lng_max']):
            raise ValueError('ç¶“åº¦è¶…å‡ºå°ç£åœ°å€ç¯„åœ')

        return True
```

### ğŸ” è³‡æ–™ä¿è­·æªæ–½

#### æ•æ„Ÿè³‡æ–™åŠ å¯†
```python
from cryptography.fernet import Fernet
import base64
import os

class DataProtection:
    def __init__(self, encryption_key=None):
        if encryption_key:
            self.key = encryption_key.encode()
        else:
            self.key = os.environ.get('ENCRYPTION_KEY', Fernet.generate_key())

        self.cipher = Fernet(self.key)

    def encrypt_sensitive_data(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿè³‡æ–™"""
        if not data:
            return data

        encrypted = self.cipher.encrypt(data.encode('utf-8'))
        return base64.urlsafe_b64encode(encrypted).decode('utf-8')

    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿè³‡æ–™"""
        if not encrypted_data:
            return encrypted_data

        try:
            decoded = base64.urlsafe_b64decode(encrypted_data.encode('utf-8'))
            decrypted = self.cipher.decrypt(decoded)
            return decrypted.decode('utf-8')
        except Exception:
            raise ValueError('è§£å¯†å¤±æ•—ï¼Œè³‡æ–™å¯èƒ½å·²æå£')

    def secure_hash(self, data: str) -> str:
        """å®‰å…¨é›œæ¹Š"""
        import hashlib
        import secrets

        salt = secrets.token_hex(16)
        hash_obj = hashlib.pbkdf2_hmac('sha256', data.encode('utf-8'), salt.encode('utf-8'), 100000)
        return f"{salt}:{hash_obj.hex()}"
```

---

## çµèª

æœ¬ä½¿ç”¨æŒ‡å—æ¶µè“‹äº†å°ç£é†«ç™‚ AI åŠ©ç†çš„å…¨é¢ä½¿ç”¨æ–¹æ³•ï¼Œå¾åŸºæœ¬ API æ“ä½œåˆ°é€²éšæ•´åˆæ‡‰ç”¨ã€‚è«‹æ ¹æ“šæ‚¨çš„å…·é«”éœ€æ±‚é¸æ“‡é©åˆçš„æ•´åˆæ–¹å¼ï¼Œä¸¦å‹™å¿…éµå¾ªæœ€ä½³å¯¦è¸ä»¥ç¢ºä¿ç³»çµ±å®‰å…¨èˆ‡æ•ˆèƒ½ã€‚

### ğŸ“ æŠ€è¡“æ”¯æ´

å¦‚é‡åˆ°æŠ€è¡“å•é¡Œï¼Œè«‹ä¾ç…§ä»¥ä¸‹é †åºè™•ç†ï¼š

1. **æŸ¥é–±æœ¬ä½¿ç”¨æŒ‡å—çš„æ•…éšœæ’é™¤ç« ç¯€**
2. **æª¢æŸ¥ API æ–‡ä»¶ï¼š** `http://localhost:8000/docs`
3. **æŸ¥çœ‹ç³»çµ±ç›£æ§ï¼š** `http://localhost:8000/v1/monitoring/dashboard`
4. **è¯çµ¡æŠ€è¡“æ”¯æ´åœ˜éšŠ**

### âš ï¸ é‡è¦æé†’

- æœ¬ç³»çµ±åƒ…ä¾›é†«ç™‚è³‡è¨Šåƒè€ƒï¼Œä¸å–ä»£å°ˆæ¥­é†«ç™‚è¨ºæ–·
- ç·Šæ€¥ç‹€æ³è«‹ç«‹å³æ’¥æ‰“ 119 æˆ– 112
- éµå¾ª PDPA å€‹äººè³‡æ–™ä¿è­·æ³•è¦ç¯„
- å®šæœŸæ›´æ–°ç³»çµ±ä»¥ç¢ºä¿å®‰å…¨æ€§

---

*æœ€å¾Œæ›´æ–°ï¼š2024å¹´9æœˆ19æ—¥*